(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{520:function(t,_,s){"use strict";s.r(_);var a=s(2),v=Object(a.a)({},(function(){var t=this,_=t.$createElement,s=t._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"_1-数据类型有哪些-？类型判断有哪些-优缺点？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据类型有哪些-？类型判断有哪些-优缺点？"}},[t._v("#")]),t._v(" 1. 数据类型有哪些 ？类型判断有哪些 优缺点？")]),t._v(" "),s("p",[t._v("基本数据类型 Boolean Null Undefined Number String Symbol BigInt")]),t._v(" "),s("p",[t._v("引用数据类型 Object, 包含 Date function Array")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("typeof")]),t._v(" "),s("ul",[s("li",[t._v("对于非 Object的基本数据类型，除了null，均可判断")]),t._v(" "),s("li",[t._v("对于null 返回 object")]),t._v(" "),s("li",[t._v("对于引用数据类型，除了function，都返回object")]),t._v(" "),s("li",[t._v("对于function 返回 function")]),t._v(" "),s("li",[t._v("typeof(typeof a) 返回 string")])])]),t._v(" "),s("li",[s("p",[t._v("instanceof")]),t._v(" "),s("p",[t._v("A instanceof B 就是用来判断B的原型是否在A的原型链上")])]),t._v(" "),s("li",[s("p",[t._v("Object.prototype.toString.call 最全面")])]),t._v(" "),s("li",[s("p",[t._v("constructor")])])]),t._v(" "),s("h3",{attrs:{id:"_2-koa2、koa1、express-比较"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-koa2、koa1、express-比较"}},[t._v("#")]),t._v(" 2.koa2、koa1、express 比较")]),t._v(" "),s("p",[t._v("在koa中，一切的流程都是中间件，数据流向遵循洋葱模型，先入后出，是按照类似堆栈的方式组织和执行的。")]),t._v(" "),s("p",[t._v("koa2和koa1的最大区别是koa2实现异步是通过async/await，koa1实现异步是通过generator/yield，而express实现异步是通过回调函数的方式。")]),t._v(" "),s("p",[t._v("koa2与express提供的API大致相同，express是大而全，内置了大多数的中间件，更让人省心，koa2不绑定任何的框架，干净简洁，小而精，更容易实现定制化，拓展性好。")]),t._v(" "),s("p",[t._v("express是没有提供ctx来提供上下流服务，需要更多地手动处理，express本身是不支持洋葱模型的数据流入流出能力，需要引入其他插件。")]),t._v(" "),s("h3",{attrs:{id:"_3-http-和-https-的区别-为什么https-就更安全呢？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-http-和-https-的区别-为什么https-就更安全呢？"}},[t._v("#")]),t._v(" 3. http 和 https 的区别 为什么https 就更安全呢？")]),t._v(" "),s("p",[t._v("http 协议是明文传输数据，在传输过程中容易被窃取或者篡改，容易遭受中间人攻击。")]),t._v(" "),s("p",[t._v("所以为了访问更加安全，我们引入了加密方案，在 TCP 和 HTTP 之间插入了一个安全层。安全层有两个职责，对发起 http 请求的数据进行加密操作和对接收到http的内容进行解密操作。")]),t._v(" "),s("ul",[s("li",[t._v("第一版 对称加密 加密和解密使用的都是相同的密钥 （速度快 安全性低）")]),t._v(" "),s("li",[t._v("第二版 非对称加密 有两把A、B两把密钥，如果你使用 A密钥来加密，那么只能使用B密钥来解密；反过来，如果你要用B密钥加密，那么只能使用A密钥来解密。(速度慢 安全性比较高)")]),t._v(" "),s("li",[t._v("第三版 对称加密和非对称加密搭配使用 (黑客可以通过dns劫持，这样访问的就是黑客的服务器了。)")]),t._v(" "),s("li",[t._v("第四版 添加数字证书 （更安全的做法）")])]),t._v(" "),s("h3",{attrs:{id:"_4-从输入-url-到页面显示发生了啥？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-从输入-url-到页面显示发生了啥？"}},[t._v("#")]),t._v(" 4. 从输入 url 到页面显示发生了啥？")]),t._v(" "),s("ul",[s("li",[t._v("DNS 解析")]),t._v(" "),s("li",[t._v("TCP 连接 (三次握手 四次挥手)")]),t._v(" "),s("li",[t._v("HTTP 请求")]),t._v(" "),s("li",[t._v("服务器处理 HTTP 请求 并返回 HTTP 报文")]),t._v(" "),s("li",[t._v("浏览器解析渲染页面")]),t._v(" "),s("li",[t._v("连接结束")])]),t._v(" "),s("h3",{attrs:{id:"_5-http-缓存机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-http-缓存机制"}},[t._v("#")]),t._v(" 5.HTTP 缓存机制")]),t._v(" "),s("p",[t._v("强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。")]),t._v(" "),s("p",[t._v("协商缓存：浏览器发送请求到服务器，服务器判断是否可使用本地缓存。")]),t._v(" "),s("h3",{attrs:{id:"_6-什么是闭包，为什么要用它？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-什么是闭包，为什么要用它？"}},[t._v("#")]),t._v(" 6. 什么是闭包，为什么要用它？")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("红宝书：闭包是指有权访问另一个函数作用域中变量的函数，\n\nMDN：闭包是指那些能够访问自由变量的函数。（其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。")]),t._v(" "),s("h3",{attrs:{id:"_7-js-延迟加载的方式有哪些？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-js-延迟加载的方式有哪些？"}},[t._v("#")]),t._v(" 7. js 延迟加载的方式有哪些？")]),t._v(" "),s("p",[t._v("js 延迟加载指等页面加载完成之后再加载 js 文件，这有助于提高页面加载速度。")]),t._v(" "),s("p",[t._v("一般有以下几种方式：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("defer 属性")])]),t._v(" "),s("li",[s("p",[t._v("async 属性")])]),t._v(" "),s("li",[s("p",[t._v("动态创建 DOM 方式")])]),t._v(" "),s("li",[s("p",[t._v("使用 setTimeout 延迟方法")])]),t._v(" "),s("li",[s("p",[t._v("让 JS 最后加载")])])]),t._v(" "),s("p",[t._v("js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望js脚本能够尽可能的延迟加载，提高页面的渲染速度。")]),t._v(" "),s("h3",{attrs:{id:"_8-null-是对象吗？-为什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-null-是对象吗？-为什么？"}},[t._v("#")]),t._v(" 8. null 是对象吗？ 为什么？")]),t._v(" "),s("p",[t._v("null不是对象，尽管 typeof null = object 。")]),t._v(" "),s("p",[t._v("因为这是 js 一个久远的bug，在js最初实现时，值是由一个表示类型的标签和实际数据表示的，而对象的标签是 0。又因为null 代表的是空指针，标签也是0，所以 typeof null 是 'object'。因此 null 不是 对象。")]),t._v(" "),s("h3",{attrs:{id:"_9-0-1-0-2为什么不等于0-3？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-0-1-0-2为什么不等于0-3？"}},[t._v("#")]),t._v(" 9. 0.1+0.2为什么不等于0.3？")]),t._v(" "),s("p",[t._v("0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。")]),t._v(" "),s("h3",{attrs:{id:"_10-如何理解bigint"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-如何理解bigint"}},[t._v("#")]),t._v(" 10. 如何理解BigInt?")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("因为在js 中，所有的数字都以双精度64位浮点格式表示，这导致 js 中的 Number 无法精确表示非常大的整数，会出现精度问题。也会有一定的安全问题。")]),t._v(" "),s("p",[t._v("创建BigInt, 只需要在数字末尾追加 n 即刻。")]),t._v(" "),s("p",[t._v('或者使用 BigInt 构造函数，BigInt("321321372198367981268")')])])}),[],!1,null,null,null);_.default=v.exports}}]);