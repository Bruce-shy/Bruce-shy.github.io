(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{501:function(a,t,s){"use strict";s.r(t);var r=s(2),v=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"async-await：使用同步的方式去写异步代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-await：使用同步的方式去写异步代码"}},[a._v("#")]),a._v(" async/await：使用同步的方式去写异步代码")]),a._v(" "),s("p",[a._v("使用 promise.then 也是相当复杂，虽然整个请求流程已经线性化了，但是代码里面包含了大量的 then 函数，使得代码依然不是太容易阅读。"),s("strong",[a._v("基于这个原因，ES7 引入了 async/await，这是 JavaScript 异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰。")])]),a._v(" "),s("h3",{attrs:{id:"生成器-vs-协程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生成器-vs-协程"}},[a._v("#")]),a._v(" 生成器 VS 协程")]),a._v(" "),s("p",[a._v("Generator(生成器) 的底层实现机制——协程（Coroutine）\nasync/await 使用了 Generator 和 Promise 两种技术")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。")])]),a._v(" "),s("li",[s("strong",[a._v("协程是一种比线程更加轻量级的存在。")]),a._v(" "),s("ul",[s("li",[a._v("可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行")])])]),a._v(" "),s("li",[s("strong",[a._v("如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。")])])]),a._v(" "),s("h4",{attrs:{id:"协程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协程"}},[a._v("#")]),a._v(" 协程")]),a._v(" "),s("p",[a._v("不是被操作系统内核所管理， 而完全是由程序所控制的。")]),a._v(" "),s("p",[a._v("性能提升，减少资源浪费。")]),a._v(" "),s("h4",{attrs:{id:"生成器函数的特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生成器函数的特性"}},[a._v("#")]),a._v(" 生成器函数的特性")]),a._v(" "),s("p",[a._v("可以暂停执行，也可以恢复执行。")]),a._v(" "),s("h4",{attrs:{id:"生成器函数的具体使用方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生成器函数的具体使用方式"}},[a._v("#")]),a._v(" 生成器函数的具体使用方式")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v(".next() 方法返回一个对象，有 value 和 done 两个属性\nvalue 表示函数内返回的内容\ndone 是个布尔值 表示是否完成\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])])]),a._v(" "),s("li",[s("p",[a._v("外部函数可以通过 next 方法恢复函数的执行。")])])]),a._v(" "),s("h3",{attrs:{id:"async-await"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[a._v("#")]),a._v(" async/await")]),a._v(" "),s("h3",{attrs:{id:"async"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async"}},[a._v("#")]),a._v(" async")]),a._v(" "),s("ul",[s("li",[a._v("async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。\n重点: (异步执行和隐式返回 Promise。)")])]),a._v(" "),s("h3",{attrs:{id:"await"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#await"}},[a._v("#")]),a._v(" await")]),a._v(" "),s("p",[a._v("async 函数返回的是一个 Promise 对象")]),a._v(" "),s("h3",{attrs:{id:"async-的一些讨论"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-的一些讨论"}},[a._v("#")]),a._v(" async 的一些讨论")]),a._v(" "),s("h3",{attrs:{id:"async-会取代-generator-吗？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-会取代-generator-吗？"}},[a._v("#")]),a._v(" async 会取代 Generator 吗？")]),a._v(" "),s("p",[a._v("在异步方面， async 可以取代 Generator  ， 但是 async 和 Generator  两个语法本身是用来解决不同的问题的。")]),a._v(" "),s("h3",{attrs:{id:"async-会取代-promise-吗-？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-会取代-promise-吗-？"}},[a._v("#")]),a._v(" async 会取代 Promise 吗 ？")]),a._v(" "),s("ol",[s("li",[a._v("async 函数也会返回一个 Promise 对象")]),a._v(" "),s("li",[a._v("面对复杂的异步流程， Promise 提供的 all 和 race 会更加好用")]),a._v(" "),s("li",[a._v("Promise 本身是一个对象， 所以可以在代码中任意传递")]),a._v(" "),s("li",[a._v("async 支持率目前还很低。")])]),a._v(" "),s("h3",{attrs:{id:"async-的一些讨论-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-的一些讨论-2"}},[a._v("#")]),a._v(" async 的一些讨论")]),a._v(" "),s("p",[a._v("使用 async/await 可以实现用同步代码的风格来编写异步代码，这是因为 async/await 的基础技术使用了生成器和 Promise，生成器是协程的实现，利用生成器能实现生成器函数的暂停和恢复。")]),a._v(" "),s("h3",{attrs:{id:"event-loop-事件循环机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#event-loop-事件循环机制"}},[a._v("#")]),a._v(" Event-loop (事件循环机制)")]),a._v(" "),s("h4",{attrs:{id:"what"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#what"}},[a._v("#")]),a._v(" what?")]),a._v(" "),s("p",[a._v("Event-loop 是计算机系统的一种运行机制")]),a._v(" "),s("h4",{attrs:{id:"宏任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#宏任务"}},[a._v("#")]),a._v(" 宏任务")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("渲染事件（如解析 DOM、计算布局、绘制）；")])]),a._v(" "),s("li",[s("p",[a._v("用户交互事件（如鼠标点击、滚动页面、放大缩小等）；")])]),a._v(" "),s("li",[s("p",[a._v("JavaScript 脚本执行事件；(setTimeout)；")])]),a._v(" "),s("li",[s("p",[a._v("网络请求完成、文件读写完成事件。")])])]),a._v(" "),s("p",[a._v("主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。(由宿主环境引起的任务)。")]),a._v(" "),s("h4",{attrs:{id:"流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[a._v("#")]),a._v(" 流程")]),a._v(" "),s("p",[a._v("整体代码作为宏任务，进入主线程")]),a._v(" "),s("p",[a._v("只要宏任务队列不为空：")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("从宏任务队列取出 "),s("strong",[a._v("一个")]),a._v(" 执行")])]),a._v(" "),s("li",[s("p",[a._v("从微任务队列里面取出 "),s("strong",[a._v("所有的")]),a._v(" 执行，如果在这执行过程中又产生了微任务，再次重复第二步。")])]),a._v(" "),s("li",[s("p",[a._v("有可能进入浏览器的重新渲染。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("reqAnimationframe 回调")])]),a._v(" "),s("li",[s("p",[a._v("执行 IntersectionObserver 回调")])]),a._v(" "),s("li",[s("p",[a._v("重新绘制渲染")])])])])]),a._v(" "),s("h4",{attrs:{id:"结论"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#结论"}},[a._v("#")]),a._v(" 结论")]),a._v(" "),s("p",[a._v("在一个宏任务中， 分别创建一个用于回调的宏任务和微任务，无论什么时候，微任务都早于宏任务执行。")])])}),[],!1,null,null,null);t.default=v.exports}}]);