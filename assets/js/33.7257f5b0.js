(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{522:function(t,v,_){"use strict";_.r(v);var a=_(2),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h3",{attrs:{id:"osi七层模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#osi七层模型"}},[t._v("#")]),t._v(" OSI七层模型")]),t._v(" "),_("p",[t._v("应用层：文件传输，常用协议HTTP，snmp,FTP ,")]),t._v(" "),_("p",[t._v("表示层：数据格式化，代码转换，数据加密，")]),t._v(" "),_("p",[t._v("会话层：建立，解除会话")]),t._v(" "),_("p",[t._v("传输层：提供端对端的接口，tcp,udp")]),t._v(" "),_("p",[t._v("网络层：为数据包选择路由，IP，icmp")]),t._v(" "),_("p",[t._v("数据链路层：传输有地址的帧")]),t._v(" "),_("p",[t._v("物理层：二进制的数据形式在物理媒体上传输数据")]),t._v(" "),_("h3",{attrs:{id:"cdn-原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cdn-原理"}},[t._v("#")]),t._v(" CDN 原理")]),t._v(" "),_("p",[t._v("CDN叫做内容分发网络，它的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应。")]),t._v(" "),_("h3",{attrs:{id:"tcp建立连接的三次握手过程-三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp建立连接的三次握手过程-三次握手"}},[t._v("#")]),t._v(" TCP建立连接的三次握手过程(三次握手)")]),t._v(" "),_("p",[t._v("第一次握手：起初两端都处于CLOSED关闭状态，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；")]),t._v(" "),_("p",[t._v("第二次握手：Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量；")]),t._v(" "),_("p",[t._v("第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据。")]),t._v(" "),_("h3",{attrs:{id:"说一下用户从输入url到显示页面这个过程发生了什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#说一下用户从输入url到显示页面这个过程发生了什么"}},[t._v("#")]),t._v(" 说一下用户从输入url到显示页面这个过程发生了什么")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("DNS 解析")])]),t._v(" "),_("li",[_("p",[t._v("TCP 连接")])]),t._v(" "),_("li",[_("p",[t._v("发送 HTTP 请求")])]),t._v(" "),_("li",[_("p",[t._v("服务器处理 HTTP 请求并返回HTTP报文")])]),t._v(" "),_("li",[_("p",[t._v("浏览器解析渲染页面")])]),t._v(" "),_("li",[_("p",[t._v("连接结束")])])]),t._v(" "),_("h3",{attrs:{id:"常见的请求方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见的请求方法"}},[t._v("#")]),t._v(" 常见的请求方法")]),t._v(" "),_("p",[t._v("GET， POST， HEAD， PUT， DELETE， OPTIONS")]),t._v(" "),_("p",[t._v("GET 请求数据，把参数包含在URL中。")]),t._v(" "),_("p",[t._v("POST 提交数据，通过request body (请求体) 传递参数")]),t._v(" "),_("p",[t._v("从协议本身来说， 并没有限制 GET 传递参数不能放到 body, POST 传递参数 也可以放到 querstring。")]),t._v(" "),_("p",[t._v("相对于来说 POST 比 GET 更安全一些，但是两种本质上来说都是不安全的，因为http是明文传输的，应该使用https。")]),t._v(" "),_("p",[_("strong",[t._v("重大区别：GET产生一个TCP数据包；POST产生两个TCP数据包。")])]),t._v(" "),_("p",[t._v("对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；")]),t._v(" "),_("p",[t._v("而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。")]),t._v(" "),_("h3",{attrs:{id:"http-状态码，301和302有什么具体区别，200和304-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-状态码，301和302有什么具体区别，200和304-的区别"}},[t._v("#")]),t._v(" HTTP 状态码，301和302有什么具体区别，200和304 的区别")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("1xx 表示信息响应类，")])]),t._v(" "),_("li",[_("p",[t._v("2xxx 表示成功响应类，")])]),t._v(" "),_("li",[_("p",[t._v("3xx 表示重定向响应类，")])]),t._v(" "),_("li",[_("p",[t._v("4xx 表示客户端错误，")])]),t._v(" "),_("li",[_("p",[t._v("5xx 表示服务器错误")])])]),t._v(" "),_("p",[t._v("常见的状态码有101切换协议，200成功，301永久重定向，302临时重定向，304未修改")]),t._v(" "),_("p",[t._v("301和302的区别：301：永久移动，请求的网页已永久移动到新的位置，服务器返回此响应，会自动将请求者转到新位置，302：历史移动，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来继续以后的请求。")]),t._v(" "),_("p",[t._v("200和304：")]),t._v(" "),_("p",[t._v("200表示成功，服务器已成功处理了请求，通常表示为服务器提供了请求的网页，304表示未修改，自从上次请求后，请求的网页未修改过，服务器返回此响应时不会返回网页内容")]),t._v(" "),_("h3",{attrs:{id:"tcp和udp的区别，为什么三次握手四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp的区别，为什么三次握手四次挥手"}},[t._v("#")]),t._v(" TCP和UDP的区别，为什么三次握手四次挥手")]),t._v(" "),_("ol",[_("li",[t._v("UDP（用户数据包协议）数据包易丢失，而且UDP不知道如何组装这些数据包")]),t._v(" "),_("li",[t._v("TCP（传输控制协议）保证数据包传输的不可丢失性，TCP提供重传功能。TCP头提供用于排序的序列号，用来保证把乱序的数据包组合成一个完整的文件")])]),t._v(" "),_("h4",{attrs:{id:"为什么tcp要进行四次挥手？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么tcp要进行四次挥手？"}},[t._v("#")]),t._v(" 为什么TCP要进行四次挥手？")]),t._v(" "),_("p",[t._v("因为是双方彼此都建立了连接，因此双方都要释放自己的连接，A向B发出一个释放连接请求，他要释放链接表明不再向B发送数据了，此时B收到了A发送的释放链接请求之后，给A发送一个确认，A不能再向B发送数据了，它处于FIN-WAIT-2的状态，但是此时B还可以向A进行数据的传送。此时B向A 发送一个断开连接的请求，A收到之后给B发送一个确认。此时B关闭连接。A也关闭连接。")]),t._v(" "),_("p",[t._v("为什么要有TIME-WAIT这个状态呢，这是因为有可能最后一次确认丢失，如果B此时继续向A发送一个我要断开连接的请求等待A发送确认，但此时A已经关闭连接了，那么B永远也关不掉了，所以我们要有TIME-WAIT这个状态。")]),t._v(" "),_("p",[t._v("当然TCP也并不是100%可靠的。")]),t._v(" "),_("h3",{attrs:{id:"http缓存机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http缓存机制"}},[t._v("#")]),t._v(" HTTP缓存机制")]),t._v(" "),_("p",[t._v("HTTP缓存即是浏览器第一次向一个服务器发起HTTP请求后，服务器会返回请求的资源，并且在响应头中添加一些有关缓存的字段如：cache-control，expires, last-modifed，ETag, Date等，之后浏览器再向该服务器请求资源就可以视情况使用强缓存和协商缓存，")]),t._v(" "),_("p",[t._v("强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互，")]),t._v(" "),_("p",[t._v("协商缓存：浏览器发送请求到服务器，服务器判断是否可使用本地缓存，")]),t._v(" "),_("h4",{attrs:{id:"强制缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[t._v("#")]),t._v(" 强制缓存")]),t._v(" "),_("p",[t._v("对于强制缓存，服务器响应的header中会用两个字段来表明——Expires和Cache-Control。")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("Expires：Expires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。")])]),t._v(" "),_("li",[_("p",[t._v("Cache-Control：Cache-Control有很多属性，不同的属性代表的意义也不同。 private：客户端可以缓存 public：客户端和代理服务器都可以缓存 max-age=t：缓存内容将在t秒后失效 no-cache：需要使用协商缓存来验证缓存数据 no-store：所有内容都不会缓存。")])])]),t._v(" "),_("h4",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),_("p",[t._v("协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。")]),t._v(" "),_("h5",{attrs:{id:"last-modified"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#last-modified"}},[t._v("#")]),t._v(" Last-Modified")]),t._v(" "),_("p",[t._v("Last-Modified： 服务器在响应请求时，会告诉浏览器资源的最后修改时间。")]),t._v(" "),_("p",[t._v("if-Modified-Since: 浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。 从字面上看，就是说：从某个时间节点算起，是否文件被修改了")]),t._v(" "),_("ol",[_("li",[t._v("如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK")]),t._v(" "),_("li",[t._v("如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified")])]),t._v(" "),_("p",[t._v("if-Unmodified-Since: 从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改")]),t._v(" "),_("ol",[_("li",[t._v("如果没有被修改:则开始`继续'传送文件: 服务器返回: 200 OK")]),t._v(" "),_("li",[t._v("如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)")])]),t._v(" "),_("p",[t._v("这两个的区别是一个是修改了才下载一个是没修改才下载。 Last-Modified 说好却也不是特别好，因为"),_("u",[t._v("如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag。")])]),t._v(" "),_("h5",{attrs:{id:"etag"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#etag"}},[t._v("#")]),t._v(" Etag")]),t._v(" "),_("p",[t._v("Etag： 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）")]),t._v(" "),_("p",[t._v("If-None-Match： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。")]),t._v(" "),_("ol",[_("li",[t._v("不同，说明资源被改动过，则响应整个资源内容，返回状态码200。")]),t._v(" "),_("li",[t._v("相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304.")])]),t._v(" "),_("p",[t._v("但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了。(MD5 加密算法)")]),t._v(" "),_("h3",{attrs:{id:"缓存的优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存的优点"}},[t._v("#")]),t._v(" 缓存的优点")]),t._v(" "),_("ol",[_("li",[t._v("减少了冗余的数据传递，节省宽带流量")]),t._v(" "),_("li",[t._v("减少了服务器的负担，大大提高了网站性能")]),t._v(" "),_("li",[t._v("加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因。")])]),t._v(" "),_("h3",{attrs:{id:"不同刷新的请求执行过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不同刷新的请求执行过程"}},[t._v("#")]),t._v(" 不同刷新的请求执行过程")]),t._v(" "),_("ol",[_("li",[t._v("浏览器地址栏中写入URL，回车 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）")]),t._v(" "),_("li",[t._v("F5 F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since。")]),t._v(" "),_("li",[t._v("Ctrl+F5 告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作.")])]),t._v(" "),_("h3",{attrs:{id:"http0-9、http1-x-和-http2-x-有哪些区别？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http0-9、http1-x-和-http2-x-有哪些区别？"}},[t._v("#")]),t._v(" http0.9、http1.x 和  http2.x 有哪些区别？")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("http0.9 超文本传输协议")])]),t._v(" "),_("li",[_("p",[t._v("http1.x 改进了持久连接，提供虚拟主机的支持")]),t._v(" "),_("ul",[_("li",[t._v("使用文本传输")]),t._v(" "),_("li",[t._v("队头阻塞，一次连接完成一次请求")])])]),t._v(" "),_("li",[_("p",[t._v("http 2.x")]),t._v(" "),_("ul",[_("li",[t._v("使用二进制传输，相对更加安全可靠")]),t._v(" "),_("li",[t._v("多路复用，建立一条连接，可以完成多条请求")]),t._v(" "),_("li",[t._v("对协议报使用压缩，降低了网络开销")]),t._v(" "),_("li",[t._v("允许服务器主动推送消息到客户端")])])])]),t._v(" "),_("h3",{attrs:{id:"资料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#资料"}},[t._v("#")]),t._v(" 资料")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://juejin.im/post/6844903517702848526",target:"_blank",rel:"noopener noreferrer"}},[t._v("掘金"),_("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=e.exports}}]);