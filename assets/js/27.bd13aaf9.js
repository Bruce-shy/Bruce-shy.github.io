(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{514:function(t,_,v){"use strict";v.r(_);var e=v(2),s=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h3",{attrs:{id:"箭头函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[t._v("#")]),t._v(" 箭头函数")]),t._v(" "),v("p",[t._v("箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比， 有以下几点差异：")]),t._v(" "),v("ol",[v("li",[t._v("函数体内的 this 对象，就是定义时所在的对象， 而不是使用时所在的对象。")]),t._v(" "),v("li",[t._v("不可以使用 arguments 对象， 该对象在函数体内不存在。如果要用， 可以用 rest 参数代替。")]),t._v(" "),v("li",[t._v("不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。")]),t._v(" "),v("li",[t._v("不可以当作构造函数，也就是说，不可以使用 new 命令， 因为：\n"),v("ul",[v("li",[t._v("没有自己的 this，无法调用 call apply")]),t._v(" "),v("li",[t._v("没有 prototype 属性，而 new 命令 在执行时需要将构造函数的 prototype 赋值给新的对象的"),v("code",[t._v("__proto__")])])])])]),t._v(" "),v("p",[t._v("上面四点中，第一点尤其值得注意。"),v("code",[t._v("this")]),t._v("对象的指向是可变的，但是在箭头函数中，它是固定的。")]),t._v(" "),v("h3",{attrs:{id:"箭头函数的注意事项及不适用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数的注意事项及不适用场景"}},[t._v("#")]),t._v(" 箭头函数的注意事项及不适用场景")]),t._v(" "),v("p",[t._v("由于箭头函数使得"),v("code",[t._v("this")]),t._v("从“动态”变成“静态”，如下场合不应该使用箭头函数。")]),t._v(" "),v("ul",[v("li",[t._v("第一个场合是"),v("strong",[t._v("定义对象的方法")]),t._v("，且该方法内部包括"),v("code",[t._v("this")]),t._v("。")]),t._v(" "),v("li",[v("strong",[t._v("需要动态this的时候")]),t._v("，也不应该使用箭头函数")]),t._v(" "),v("li",[t._v("如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。")])])])}),[],!1,null,null,null);_.default=s.exports}}]);